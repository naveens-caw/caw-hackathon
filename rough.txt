## Feature: Hackathon Monorepo Bootstrap (Atlas-style)

### What
Bootstrap a new hackathon project inside a **`caw-hackathon/`** folder using the **same tech stack and conventions as the Atlas repo**, but reduced to the essential scaffolding so I can start building features quickly. This includes a **Turborepo + pnpm** monorepo with a **React + TypeScript (Vite)** frontend and a **NestJS + TypeScript** backend, plus baseline developer tooling (lint/format/typecheck/test), **PostgreSQL + Drizzle ORM**, **Docker compose**, a **CI/CD pipeline skeleton**, and a clean **.env structure**. **Do not modify Atlas**â€”only use it as a reference for structure/config patterns.

### Technical Approach
- **Create folder structure (new project only)**
  - Create a new root folder: `caw-hackathon/`
  - Monorepo layout (minimal but extensible):
    - `apps/web` (React + TS + Vite)
    - `apps/api` (NestJS)
    - `packages/shared` (shared types/utils; includes Zod schemas)
    - `packages/db` (Drizzle schema + migrations + DB client)
    - `tooling/eslint-config` (shared ESLint config)
    - `tooling/tsconfig` (shared TS configs)

- **Monorepo orchestration**
  - Setup **Turborepo** (`turbo.json`) with pipelines for: `dev`, `build`, `lint`, `typecheck`, `test`
  - Setup **pnpm workspaces** (`pnpm-workspace.yaml`) and root `package.json` scripts to run tasks across apps

- **TypeScript (strict)**
  - Root TS configs: `tooling/tsconfig/base.json`, plus app-specific `tsconfig.json` extending shared base
  - Ensure `strict: true` and consistent path aliases (as per Atlas style)

- **Frontend**
  - `apps/web`: Vite + React + TS
  - Add: React Router v7, TanStack Query, Zustand, Tailwind, shadcn/ui, React Hook Form + Zod
  - Provide minimal example wiring:
    - Router setup with one route
    - TanStack Query provider
    - Example form using RHF + Zod

- **Backend**
  - `apps/api`: NestJS starter with:
    - Health endpoint (`GET /health`)
    - Config module reading env vars
    - DB module using `packages/db`
    - Example endpoint (`GET /api/version`) returning version + env

- **Database + ORM**
  - Postgres via Docker compose service
  - Drizzle setup in `packages/db`:
    - `schema.ts` (initial example table)
    - `drizzle.config.ts`
    - migration scripts
    - `index.ts` exporting typed client

- **Linting + formatting**
  - Shared ESLint config package in `tooling/eslint-config`
  - Prettier config at root
  - Ensure both apps and packages inherit the same rules

- **Testing scaffolding**
  - Backend: Jest (Nest default)
  - Frontend/packages: Vitest
  - E2E: Playwright (basic config and placeholder test)

- **Git hooks**
  - Husky + lint-staged to run format/lint/typecheck on staged files

- **Docker**
  - Root `docker-compose.yml` for Postgres (and optional app services as placeholders)
  - Optional `Dockerfile` skeletons for `apps/web` and `apps/api` (even if not fully used yet)

- **CI/CD skeleton**
  - Add a pipeline skeleton (e.g., GitHub Actions) with jobs:
    - install (pnpm)
    - lint
    - typecheck
    - test
    - build

- **Environment configuration**
  - Root `.env.example` plus per-app examples if needed
  - Define consistent env keys (DB URL, API port, web port, etc.)
  - Ensure backend loads env and validates via Zod (Atlas-style pattern)

### Acceptance Criteria
- [ ] A new folder `caw-hackathon/` exists and is fully independent; **Atlas is unchanged**
- [ ] From repo root, `pnpm i` installs successfully with pnpm workspaces
- [ ] `pnpm dev` starts both apps (web + api) via Turborepo
- [ ] `pnpm lint` runs ESLint across apps/packages with shared config
- [ ] `pnpm format` (or equivalent) runs Prettier consistently
- [ ] `pnpm typecheck` runs TypeScript checks across the monorepo (strict mode)
- [ ] Postgres starts with `docker compose up -d` and the backend can connect using env vars
- [ ] Drizzle migration workflow exists (generate/run) and includes an example schema/table
- [ ] API exposes `GET /health` returning 200 OK
- [ ] Web app loads and can call the API base URL (even if just a sample fetch)
- [ ] Test runners are wired:
  - [ ] `pnpm test` runs Jest for API and Vitest for web/shared
  - [ ] Playwright config exists with a placeholder e2e test
- [ ] Husky + lint-staged run on commit (at least lint + format + typecheck on staged files)
- [ ] CI pipeline skeleton exists and runs lint/typecheck/test/build on PR

### Out of Scope
- Building hackathon feature/business logic beyond the bootstrap (no real product screens)
- Full auth, RBAC, permissions, SSO
- Production-grade deployment (K8s, Terraform, secrets manager)
- Advanced DB modeling (beyond an example table + migration flow)
- Observability stack (tracing, metrics, log aggregation) beyond placeholders
- Modifying the Atlas repo or refactoring Atlas configs

### Implementation Order
1. Create `caw-hackathon/` root with `pnpm-workspace.yaml`, root `package.json`, and `turbo.json`
2. Add shared tooling packages: `tooling/tsconfig`, `tooling/eslint-config`, root Prettier config
3. Scaffold `apps/web` (Vite React TS) and `apps/api` (NestJS) with strict TS configs
4. Add `packages/shared` (Zod schemas/types) and wire it into both apps
5. Add `packages/db` with Drizzle schema/config + scripts; add Postgres in `docker-compose.yml`
6. Wire backend DB module + add `/health` endpoint; ensure env loading works
7. Add lint/typecheck scripts and ensure Turborepo pipelines work end-to-end
8. Add testing scaffolds: Jest (api), Vitest (web/shared), Playwright (e2e)
9. Add Husky + lint-staged pre-commit hooks
10. Add CI/CD pipeline skeleton to run install/lint/typecheck/test/build


-------------------------------------------

STEP 2 

## Feature: Deployment Foundation (Staging + Production)

### What
Set up and ship your existing monorepo skeleton so anyone can access a live URL (not just localhost), with separate staging and production environments. Users should be able to open the web app, the web app should call the deployed API, and both environments should expose a health check proving the system is up.

### Technical Approach
- **What files need to be created/modified**
- Create `apps/web/vercel.json` to define build output, rewrites (if needed), and environment expectations.
- Create `apps/api/render.yaml` (or equivalent service manifest) to define API service build/start commands and health check path.
- Create `docs/deployment.md` with one-time setup, env var mapping, DNS/domain notes, and rollback steps.
- Create `.github/workflows/deploy-staging.yml` for auto-deploy from `develop` (or selected staging branch).
- Create `.github/workflows/deploy-production.yml` for deploy from `main` with protected environment approval.
- Modify root `README.md` to add live environment URLs, health endpoints, and deployment runbook links.
- Modify `.env.example` to include explicit staging/production variable names and expected values.
- Modify `.github/workflows/ci.yml` to gate deployment workflows on passing checks.

- **What APIs/endpoints are involved**
- Existing `GET /health` on API remains primary liveness endpoint and must return HTTP `200` with `{ "ok": true }`.
- Existing `GET /api/version` remains smoke-test endpoint and must return app version + env.
- Web runtime must use `VITE_API_URL` in both staging and production to call deployed API origin.
- Add deployment smoke validation script/step that checks:
- `web_url` returns `200`.
- `api_url/health` returns `200`.
- `api_url/api/version` returns a valid JSON payload.

- **What the data model looks like**
- No schema changes for app data in this step.
- Environment model becomes explicit per environment:
- `NODE_ENV=production`
- `API_PORT` (Render-managed or fixed if required)
- `VITE_API_URL`
- `APP_VERSION` (from CI commit/tag)
- `DATABASE_URL` (Neon branch DB URL per env)
- Use two isolated DB branches/databases in Neon: one for staging and one for production.

- **What external dependencies are needed**
- Vercel project for `apps/web`.
- Render Web Service for `apps/api`.
- Neon Postgres project with separate staging/prod DB branches.
- GitHub Environments: `staging` and `production` with scoped secrets.
- Optional uptime monitor (Render/Vercel built-in or external) targeting `/health`.

### Acceptance Criteria
- [ ] Staging web URL is live and loads without manual local setup.
- [ ] Production web URL is live and loads without manual local setup.
- [ ] Staging API `GET /health` returns `200` and `{ "ok": true }`.
- [ ] Production API `GET /health` returns `200` and `{ "ok": true }`.
- [ ] Staging and production each return correct environment identity from `GET /api/version`.
- [ ] Web in each environment uses the correct `VITE_API_URL` and reaches only its matching API.
- [ ] Staging deploy runs automatically on staging branch pushes after CI passes.
- [ ] Production deploy runs only from `main` and requires protected approval.
- [ ] Environment secrets are separated (`staging` secrets cannot deploy to `production`).
- [ ] Deployment smoke tests fail the pipeline if web/API health checks fail.

### Out of Scope
- Full IaC/Terraform modules.
- Kubernetes/ECS/Cloud Run migration.
- Full observability platform (tracing, dashboards, alert routing).
- Auth, RBAC, or business feature delivery.
- Multi-region failover or advanced autoscaling tuning.

### Implementation Order
1. Define environment contract (`.env.example`, secret naming, staging/prod variable matrix) and create Neon staging/prod DBs.
2. Deploy API skeleton to Render with `DATABASE_URL`, `NODE_ENV`, `APP_VERSION`; verify `/health` and `/api/version`.
3. Deploy web skeleton to Vercel with correct `VITE_API_URL` for staging/prod.
4. Add GitHub Environments and deployment workflows (`deploy-staging.yml`, `deploy-production.yml`) with CI gating.
5. Add smoke checks in deploy jobs for web root, `/health`, and `/api/version`.
6. Document runbook in `docs/deployment.md` and update `README.md` with live URLs + rollback steps.
7. Run final end-to-end validation: staging deploy, production deploy, environment isolation, and rollback rehearsal.

### Test Cases and Scenarios
- Staging push triggers staging deployment and passes smoke checks.
- Main push with approval triggers production deployment and passes smoke checks.
- Wrong/missing `VITE_API_URL` causes smoke check failure (web cannot reach API).
- Wrong `DATABASE_URL` causes API health/version failure and blocks promotion.
- Manual rollback to previous deployment restores healthy `/health` within target recovery window.

### Important Public Interfaces/Types
- API contract stays stable:
- `GET /health -> 200 { ok: true }`
- `GET /api/version -> version + environment payload`
- Frontend runtime interface depends on `VITE_API_URL`; this is now a required deploy-time contract.
- CI/CD interface adds two protected deployment workflows bound to GitHub Environments.

### Assumptions and Defaults Chosen
- Platform default: `Vercel` for web and `Render` for API.
- Database default: `Neon` with separate staging and production DB branches.
- Branching default: `develop -> staging`, `main -> production`.
- Health probe default: `GET /health`.
- Release identity default: `APP_VERSION` injected from commit SHA or Git tag.

----------------------------
NEON 

npx neonctl@latest --force-auth init --agent cursor

postgresql://neondb_owner:npg_gNV2pIhq9mOf@ep-fragrant-cake-ai07dxbu-pooler.c-4.us-east-1.aws.neon.tech/neondb?sslmode=require&channel_binding=require

